<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: PPS-Client v1.4</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">PPS-Client v1.4 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="figures/RPi_with_GPS.jpg" alt="Raspberry Pi with GPS" width="400"/>
</div>
<p>The PPS-Client daemon is a fast, microsecond accuracy Pulse-Per-Second system clock synchronizer for Raspberry Pi that synchronizes the Raspberry Pi system time clock to a GPS time clock.</p>
<ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#hardware-requirements">Hardware Requirements</a></li>
<li><a href="#software-requirements">Software Requirements</a><ul>
<li><a href="#operating-system">Operating System</a></li>
<li><a href="#the-ntp-daemon">The NTP daemon</a><ul>
<li><a href="#no-ntp">No NTP</a></li>
<li>[GPS Only](gps-only)</li>
</ul>
</li>
<li><a href="#the-chkconfig-system-services-manager">The chkconfig system services manager</a></li>
</ul>
</li>
<li><a href="#installing">Installing</a><ul>
<li><a href="#get-the-files">Get the Files</a></li>
<li><a href="#compile-the-kernel">Compile the Kernel</a></li>
<li><a href="#build-pps-client">Build PPS-Client</a></li>
</ul>
</li>
<li><a href="#uninstalling">Uninstalling</a></li>
<li><a href="#reinstalling">Reinstalling</a></li>
<li><a href="#running-pps-client">Running PPS-Client</a></li>
<li><a href="#practical-limits-to-time-measurement">Practical Limits to Time Measurement</a><ul>
<li><a href="#flicker-noise">Flicker Noise</a></li>
<li><a href="#linux-os-real-time-latency">Linux OS Real-Time Latency</a></li>
<li><a href="#measurements-of-noise-and-latency">Measurements of Noise and Latency</a></li>
</ul>
</li>
</ul>
<h2># Summary </h2>
<p>The PPS-Client daemon provides timekeeping synchronization precision of 1 microsecond and a typical average timekeeping accuracy of 2 microseconds on the Raspberry Pi 3 (verified on 10 test units). Precision and accuracy at this level is possible because the PPS-Client controller uses design techniques not previously employed to discipline an application processor clock to a PPS signal.</p>
<p>The PPS-client controller is continuously self-calibrating and does not require precision temerature control. The following results were recorded while the test Raspberry Pi test units were in a partially heated room where the temperature varied over a range of about 60 to 75 deg F through 24 hours.</p>
<p>Figure 1 is a distribution of time adjustments made by the PPS-Client controller to the system clock.</p>
<div class="image">
<img src="figures/offset-distrib.png" alt="Jitter and Corrections Distrib" width="608"/>
</div>
<p>This data was captured from a Raspberry Pi 3 running Raspian with a standard 4.4.14-v7+ Linux kernel. The time corrections required to keep the rollover of the second synchronized to the rising edge of the PPS signal never exceeded 1 microsecond in this 24 hour period. This was true for all test units.</p>
<p>Figure 2 shows the system clock frequency set by the controller and the resulting <a href="https://en.wikipedia.org/wiki/Allan_variance">Allan deviation</a> for the test unit with the largest error of the ten that were tested.</p>
<div class="image">
<img src="figures/frequency-vars.png" alt="Frequency Vars over 24 hours" width="685"/>
</div>
<p>Although the clock frequency drifted slightly between each one minute frequency correction, the maximum Allan deviation of 0.045 ppm over this 24 hour period shows it to be unlikely that the clock ever drifted more than 0.100 ppm from the control point. That corresponds to a time drift of less than 0.1 microseconds per second (A clock offset of 1 ppm corresponds to a time drift of 1 microsecond per sec.)</p>
<p>Since the time slew adjustments necessary to keep the system time synchronized to the PPS never exceeded 1 microsecond each second and the clock oscillator time drift never exceeded 0.1 microsecond each second, the timekeeping control <b>precision</b> illustrated in Figure 3 was 1 microsecond over this 24 hour period for all test units.</p>
<p>As shown in Figure 3, timekeeping <b>accuracy</b> is the time offset at the rollover of the second which is also the offset between the true time and the measured time at any point in time.</p>
<div class="image">
<img src="figures/time.png" alt="Interpretation of accuracy and precision"/>
</div>
<p>Figure 4 is the distribution of measured times relative to a true time of 800,000 microseconds into each second for a typical Raspberry Pi 3 from 10 units tested over a 24 hour period.</p>
<div class="image">
<img src="figures/InterruptTimerDistrib.png" alt="Time Parameters"/>
</div>
<p>The peak of the distribution in Figure 4 is the average error for this test unit and is about 0.28 microsecond below 800,000 microseconds. For the ten test units the median average error was -0.25 microsecond and the maximum average error was -0.76 microseconds.</p>
<p>Figure 4 also shows that there are limits to accurate single-event time measurement set by clock oscillator jitter and the response time (latency) of the Linux kernel. This is discussed below in <a href="#practical-limits-to-time-measurement">Practical Limits to Time Measurement</a>.</p>
<p>For a detailed description of the PPS-Client controller and accuracy testing run Doxygen in <code>/usr/share/doc/pps-client</code> on the RPi to generate the documentation or visit the <a href="https://rascol.github.io/Raspberry-Pi-PPS-Client">PPS-Client-Pages</a> website.</p>
<h2># Hardware Requirements </h2>
<ol type="1">
<li>A Raspberry Pi 3 or Pi 2 Model B.</li>
<li>A GPS module that provides a PPS output. Development was done with the <a href="https://www.adafruit.com/products/2324">Adafruit Ultimate GPS module</a>. Others providing compatible logic levels can also be used.</li>
<li>A wired connection from a PPS source with 3.3 Volt logic outputs to GPIO 4 (pin 7) on the RPi header.</li>
<li>A wired connection from GPIO_17 (pin 11) to GPIO_22 (pin 15) to support self calibration (Note the yellow jumper in the photo above).</li>
</ol>
<h2># Software Requirements </h2>
<h2>Operating System</h2>
<p>Versions of Linux kernel 4.1 and later are supported. Currently PPS-Client v1.4 and later runs on <b>Raspian</b>. At the moment, PPS-Client is restricted to Raspian because the file locations required by the installer (and test files) are hard coded. If there is enough interest in using other OS's, these install locations could be determined by the PPS-Client config file.</p>
<h2>The NTP daemon</h2>
<p>At one time NTP was provided out of the box on Raspian. It no longer is because the NTP clock discipline code is now built into the kernel <b>and is active</b>. Even if you want to use an external program to set the time of day, NTP must be installed so that PPS-Client can access the NTP config file to disable it. If NTP is not already installed do </p><div class="fragment"><div class="line">~ $ sudo apt-get install ntp</div><div class="line">~ $ sudo reboot</div></div><!-- fragment --><p> The reboot is necessary to insure that NTP is actively checking its config file.</p>
<p>The PPS-Client default program for setting the whole second time of day is SNTP included in the NTP package. PPS-Client has been updated to use the SNTP version included in the latest NTP distribution (1:4.2.8p10+dfsg-3+deb9u1). By default SNTP maintains the date and time through DST and leap second changes and PPS-Client disciplines the system clock fractional second to the PPS. However, SNTP requires a file **/var/db/ntp-kod** that it no longer installs (see option -K in <code>man sntp</code>). If you are upgrading from an earlier version of NTP, see if the file already exists. If not, do something like this</p>
<div class="fragment"><div class="line">~ $ sudo mkdir /var/db; sudo touch /var/db/ntp-kod; sudo chmod 666 /var/db/ntp-kod</div></div><!-- fragment --><h3>No NTP</h3>
<p>Alternatively, you may want use some other program to handle setting time-of-day updates. To tell PPS-Client that it should totally ignore how the clock seconds are set, after installation use a setting in **/etc/pps-client.conf**: </p><div class="fragment"><div class="line">~ $ sudo nano /etc/pps-client.conf</div></div><!-- fragment --><p> Scroll down to the line, </p><div class="fragment"><div class="line">#sntp=disable</div></div><!-- fragment --><p> and uncomment it. PPS-Client will no longer care about whole-second time of day or how it gets set. But PPS-Client will continue to synchronize the roll-over of the second to the PPS signal.</p>
<h3>GPS Only</h3>
<p>PPS-Client can also be configured to have the GPS receiver that is providing the PPS signal provide the whole-second time of day updates as well. This enables operation with no internet connection. A Raspberry Pi configured this way could, for example, be used as a Stratum 1 time server for a LAN that is not connected to the Internet.</p>
<p>To configure this mode after installation, </p><div class="fragment"><div class="line">~ $ sudo nano /etc/pps-client.conf</div></div><!-- fragment --><p> Scroll down to the line, </p><div class="fragment"><div class="line">#serial=enable</div></div><!-- fragment --><p> and uncomment it. This will set PPS-Client to read GPS time messages from the serial port. This, of course, requires that the GPS receiver is connected to the serial port of the Raspberry Pi and that the serial port has been set for this purpose. Setting the serial port can be done on <b>Raspian</b> by using the <b>raspi-config</b> command. Details are <a href="https://learn.adafruit.com/adafruit-ultimate-gps-hat-for-raspberry-pi/pi-setup">here</a>.</p>
<p><b>GPS Only</b> can be demonstrated with no additional hardware connections if the <a href="https://www.adafruit.com/products/2324">Adafruit Ultimate GPS module</a> (visible in the picture at the top) is used because this device connects directly to the serial port of the RPi through its GPIO pins.</p>
<h2>The chkconfig system services manager</h2>
<div class="fragment"><div class="line">~ $ sudo apt-get install chkconfig</div></div><!-- fragment --><p>This is necessary if you want to install PPS-Client as a system service that will automatically start on system boot.</p>
<h2># Installing </h2>
<p>The PPS-Client program has a built-in Linux kernel driver. It is a Linux requirement that kernel drivers must be compiled on the Linux version on which they are used. This means that there is a different version of PPS-Client for every version of Linux that has been released since Linux 4.0. Because Linux versions roll over very frequently, it is impractical to provide a pre-compiled PPS-Client installer for every one. Consequently, the PPS-Client installer is built from source.</p>
<p>This situation is far from ideal because it means that PPS-Client has to be reinstalled whenever the Linux kernel in the RPi is upgraded. If there is interest in this project, the driver may be accepted into mainline in the upstream kernel and the versioning problem will go away.</p>
<p>In principle the build can be done on a cross-compiler. However, bulding directly on the Rasperry Pi is less error prone. The kernel source is downloaded and compiled and then the PPS-Client installer is compiled using the kernel build system.</p>
<p>The steps below don't do a complete kernel installation. Only enough is done to get the object files that are necessary for compiling a kernel driver. The entire installation takes about 40 minutes on Raspberry Pi 3.</p>
<h2>Get the Files</h2>
<p>Before compiling the kernel, be certain your system and tools are up to date on the Raspberry Pi. The reboot is necessary in case the Linux kernel version was updated. </p><div class="fragment"><div class="line">~ $ sudo apt-get update</div><div class="line">~ $ sudo apt-get upgrade</div><div class="line">~ $ sudo reboot</div></div><!-- fragment --><p>In your home folder on your Raspberry Pi, you might want to first set up a build folder: </p><div class="fragment"><div class="line">~ $ mkdir rpi</div><div class="line">~ $ cd rpi</div></div><!-- fragment --><p> First get missing dependencies: </p><div class="fragment"><div class="line">~/rpi $ sudo apt-get install bc</div></div><!-- fragment --><p> You might also need to install git: </p><div class="fragment"><div class="line">~ $ sudo apt-get install git</div></div><!-- fragment --><p> For retrieving the Linux source get the rpi-source script: </p><div class="fragment"><div class="line">~/rpi $ sudo wget https://raw.githubusercontent.com/notro/rpi-source/master/rpi-source -O /usr/bin/rpi-source &amp;&amp; sudo chmod +x /usr/bin/rpi-source &amp;&amp; /usr/bin/rpi-source -q --tag-update</div></div><!-- fragment --><p> Run the script to download the Linux source that matches the installed version of Linux on your RPi: </p><div class="fragment"><div class="line">~/rpi $ rpi-source -d ./ --nomake --delete</div></div><!-- fragment --><p> The script might complain about not getting the version of the compiler. If so, re-run it with the suggested flag.</p>
<p>You should now have the kernel source. But before you go further, <b>double check that the script down loaded the correct source version</b>. To determine your RPi kernel version use </p><div class="fragment"><div class="line">~/rpi $ uname -r</div></div><!-- fragment --><p> Then run </p><div class="fragment"><div class="line">~/rpi $ nano linux/Makefile</div></div><!-- fragment --><p>You should see something like this at the top of the Makefile </p><div class="fragment"><div class="line">VERSION = 4</div><div class="line">PATCHLEVEL = 9</div><div class="line">SUBLEVEL = 59</div><div class="line">EXTRAVERSION =</div><div class="line">NAME = Roaring Lionus</div><div class="line"> ...</div></div><!-- fragment --><p> The revision numbers must match the version of your Linux kernel exactly. If they do not, don't use this kernel source. Delete it and, as a fall back, retrieve the Linux kernel source for your RPi from <a href="https://github.com/raspberrypi/linux/releases">https://github.com/raspberrypi/linux/releases</a>. Sources are indexed by creation date. To determine the creation date of the Linux kernel on your RPi run </p><div class="fragment"><div class="line">~ $ uname -a</div></div><!-- fragment --><p> Locate the source you need, download it and unzip it into a directory called "linux" on the RPi in the <code>~/rpi</code> directory.</p>
<h2>Compile the Kernel</h2>
<p>On the RPi, </p><div class="fragment"><div class="line">~/rpi $ cd linux</div><div class="line">~/rpi/linux $ KERNEL=kernel7</div><div class="line">~/rpi/linux $ make bcm2709_defconfig</div></div><!-- fragment --><p>Now compile the kernel (takes about half an hour on Pi 2, 20 minutes on Pi 3): </p><div class="fragment"><div class="line">~/rpi/linux $ make -j4 zImage</div></div><!-- fragment --><p> If there are no compile errors, the last message from the compiler will be, </p><div class="fragment"><div class="line">Kernel: arch/arm/boot/zImage is ready</div></div><!-- fragment --><p> If all went well, you have the necessary kernel object files to build the PPS-Client driver. The current version of gcc seems prone to randomly segfaulting. If that happens try <code>make clean</code> and re-run the make command.</p>
<h2>Build PPS-Client</h2>
<p>If you have not already downloaded the PPS-Client project, do it now: </p><div class="fragment"><div class="line">~/rpi/linux $ cd ..</div><div class="line">~/rpi $ git clone --depth=1 https://github.com/rascol/Raspberry-Pi-PPS-Client</div><div class="line">~/rpi $ cd Raspberry-Pi-PPS-Client</div></div><!-- fragment --><p> Now make the PPS-Client installer. The <code>KERNELDIR</code> argument must point to the folder containing the compiled Linux kernel. Type or copy the commands below exactly as shown (using <b>back quotes</b> which cause the back quotes and text between to be replaced with the correct kernel version). If you are recompiling, first <code>make clean</code>.</p>
<p>``<code> ~/rpi/Raspberry-Pi-PPS-Client $ make KERNELDIR=~/rpi/linux KERNELVERS=</code>uname -r` </p><div class="fragment"><div class="line">That will build the installer. Run it on the RPi as root:</div></div><!-- fragment --><p> ~/rpi/Raspberry-Pi-PPS-Client $ sudo ./pps-client-<code>uname -r</code> </p><div class="fragment"><div class="line">That completes the PPS-Client installation.</div><div class="line"></div><div class="line"># Uninstalling</div><div class="line">---</div><div class="line"></div><div class="line">Uninstall PPS-Client on the RPi with:</div></div><!-- fragment --><p> ~ $ sudo pps-client-stop ~ $ sudo pps-client-remove </p><div class="fragment"><div class="line">This removes everything **except** the configuration file which you might want to keep if it has been modified and you intend to reinstall PPS-Client. A reinstall will not replace a PPS-Client configuration file, **/etc/pps-client.conf**, that has been modified.</div><div class="line"></div><div class="line">To remove everything do:</div></div><!-- fragment --><p> ~ $ sudo pps-client-remove -a </p><div class="fragment"><div class="line"># Reinstalling</div><div class="line">---</div><div class="line"></div><div class="line">To reinstall, or to install a new version of PPS-Client over an old version, first uninstall as [described above](#uninstalling) then install. If you kept a modified **/etc/pps-client.conf** file, the new install will **not** replace it. Instead the new config file will be copied to **/etc/pps-client.conf.default** to give you the choice of replacing it later.</div><div class="line"></div><div class="line"></div><div class="line"># Running PPS-Client</div><div class="line">---</div><div class="line"></div><div class="line">PPS-Client requires that a PPS hardware signal is available from a GPS module and all wired connections for the GPS module [are in place](#hardware-requirements). Once the GPS is connected and the PPS output is present on GPIO 4 you can do a quick try-out with,</div></div><!-- fragment --><p> ~ $ sudo pps-client </p><div class="fragment"><div class="line">That installs pps-client as a daemon. To watch the controller acquire you can subsequently enter</div></div><!-- fragment --><p> ~ $ pps-client -v </p><div class="fragment"><div class="line">That runs a secondary copy of PPS-Client that just displays a status printout that the PPS-Client daemon continuously generates and saves to a memory file. When PPS-Client starts up you can expect to see something like the following in the status printout:</div><div class="line"></div><div class="line">&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;figures/StatusPrintoutOnStart.png&quot; alt=&quot;Status Printout on Startup&quot; width=&quot;634&quot;/&gt;&lt;/p&gt;</div><div class="line"></div><div class="line">The `jitter` value is showing the fractional second offset of the PPS signal according to the system clock. That value will decrease second by second as the controller locks to the PPS signal. After about 10 minutes the status printout will look like this:</div><div class="line"></div><div class="line">&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;figures/StatusPrintoutAt10Min.png&quot; alt=&quot;Status Printout after 10 Min&quot; width=&quot;634&quot;/&gt;&lt;/p&gt;</div><div class="line"></div><div class="line">The `jitter` is displaying small numbers. The time of the rising edge of the PPS signal is shown in the second column. The `clamp` value on the far right indicates that the maximum time correction applied to the system clock is being limited to one microsecond. The system clock is synchronized to the PPS signal to a precision of one microsecond (but with an absolute accuracy limited by clock oscillator noise which could have as much as 1 microsecond of [RMS](https://en.wikipedia.org/wiki/Root_mean_square) jitter).</div><div class="line"></div><div class="line">It can take as long as 20 minutes for PPS-Client to fully acquire the first time it runs. This happens if the `jitter` shown in the status printout is on the order of 100,000 microseconds or more. It&#39;s quite common for the NTP fractional second to be off by that amount on a cold start. In this case PPS-Client may restart several times as it slowly reduces the `jitter` offset. That happens because system functions that PPS-Client calls internally prevent time changes of more than about 500 microseconds in each second.</div><div class="line"></div><div class="line">These are the parameters shown in the status printout:</div><div class="line"></div><div class="line"> * First two columns - date and time of the rising edge of the PPS signal.</div><div class="line"> * Third column - the sequence count, i.e., the total number of PPS interrupts received since PPS-Client was started.</div><div class="line"> * jitter - the time deviation in microseconds recorded at the reception of the PPS interrupt.</div><div class="line"> * freqOffset - the frequency offset of the system clock in parts per million of the system clock frequency.</div><div class="line"> * avgCorrection - the second-by-second average over the previous minute of the time correction (in parts per million) that is applied once per minute to the system clock.</div><div class="line"> * clamp - the hard limit (in microsecs) applied to the raw time error to convert it to a time correction.</div><div class="line"></div><div class="line">About every sixth line, interrupt delay parameters are also shown. The interval will larger when PPS-Client discards a PPS interrupt delayed more than 3 microseconds.</div><div class="line"></div><div class="line">To stop the display type ctrl-c.</div><div class="line"></div><div class="line">The daemon will continue to run until you reboot the system or until you stop the daemon with</div></div><!-- fragment --><p> ~ $ sudo pps-client-stop </p><div class="fragment"><div class="line">To have the PPS-Client daemon be installed as a system service and loaded on system boot, from an RPi terminal enter:</div></div><!-- fragment --><p> ~ $ sudo chkconfig &ndash;add pps-client </p><div class="fragment"><div class="line">If you have installed PPS-Client as a system service you should start it with </div></div><!-- fragment --><p> ~ $ sudo service pps-client start </p><div class="fragment"><div class="line">and you should stop it with</div></div><!-- fragment --><p> ~ $ sudo service pps-client stop ``<code> The "&lt;/tt&gt;pps-client -v`" command continues to work as described above.</code></p>
<p><code></p><h2># Practical Limits to Time Measurement </h2>
<p></code></p>
<p><code></code></p>
<p><code>While PPS-Client will synchronize the system clock to a GPS clock with an average accuracy of two microseconds, there are practical limits imposed by the hardware and the operating system that limit single-event timing accuracy. The hardware limit is <a href="https://en.wikipedia.org/wiki/Flicker_noise">flicker noise</a>, a kind of low frequency noise that is present in all crystal oscillators. The operating system limit is the real-time performance of the Linux OS.</code></p>
<p><code></p><h2>Flicker Noise</h2>
<p></code></p>
<p><code></code></p>
<p><code>The Raspberry Pi is an ARM processor that generates all internal timing with a conventional integrated circuit oscillator timed by an external crystal. Consequently the RPi is subject to crystal oscillator flicker noise. In the case of the RPi, flicker noise appears as a random deviation of system time from the PPS signal of up to a few microseconds. Even though flicker noise is always present, it is not evident when timing intervals between events occurring in software running on the same system. It only becomes evident when timing events external to the processor or between two systems.</code></p>
<p><code>Flicker noise sets the absolute limit on the accuracy of the system clock. This is true not only of the RPi ARM processor but also of all conventional application processors.</code></p>
<p><code></p><h2>Linux OS Real-Time Latency</h2>
<p></code></p>
<p><code></code></p>
<p><code>The Linux OS was never designed to be a real-time operating system. Nevertheless, because of considerable interest in upgrading it to provide real-time performance, real-time performance improved significantly between versions 3 and 4. As a result, median system latency in responding to an external interrupt on the RPi ARM processor is currently about 6 microseconds - down from about 23 microseconds in Linux 3. As yet, however, longer sporadic delays still occur.</code></p>
<p><code></p><h2>Measurements of Noise and Latency</h2>
<p></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></p><div class="image">
<img src="figures/SingleEventTimerDistrib.png" alt="Jitter Distribution"/>
</div>
<p></code></p>
<p><code></code></p>
<p><code>Figure 5 is a typical 24-hour accumulation of single-event timings for external interrupts at 800,000 microseconds after the PPS interrupt. The main peak is the result of reasonably constant system latency and clock oscillator flicker noise having a standard deviation of about 0.8 microsecond. The secondary peak at about 800,003 microseconds is one of many such features introduced by OS latency that can appear for hours or days or disappear altogether. The jitter samples to the right of the main peak that can only be seen in the logarithmic plot were delayed time samples of the PPS signal also introduced by OS latency.</code></p>
<p><code>Consequently, while flicker noise limits synchronization accuracy of events on different Raspberry Pi computers timed by the system click to a few microseconds (~1 μsec SD), the real-time performance of the Linux OS (as of v4.4.14-v7+) sets the accuracy of timing external events to about 20 microseconds (Pi 3) because of sporadic system interrupt latency. </code></p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
