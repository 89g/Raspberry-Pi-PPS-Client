<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>PPS-Client: Raspberry Pi PPS Client Documentation (rev. a)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PPS-Client
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
   <div id="projectbrief">Client for synchronizing the system clock to a GPS PPS source</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Raspberry Pi PPS Client Documentation (rev. a) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a href="#uses">Uses</a></li>
<li><a href="#achieving-high-accuracy-timekeeping">Achieving High Accuracy Timekeeping</a><ul>
<li><a href="#noise">Noise</a><ul>
<li><a href="#raspberry-pi-2">Raspberry Pi 2</a></li>
<li><a href="#raspberry-pi-3">Raspberry Pi 3</a></li>
<li><a href="#jitter-spikes">Jitter Spikes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#the-pps-client-controller">The pps-client Controller</a><ul>
<li><a href="#feedback-controller">Feedback Controller</a></li>
<li><a href="#feedforward-compensator">Feedforward Compensator</a></li>
<li><a href="#controller-behavior-on-startup">Controller Behavior on Startup</a></li>
<li><a href="#performance-under-stress">Performance Under Stress</a></li>
<li><a href="#error-handling">Error Handling</a></li>
</ul>
</li>
<li><a href="#testing">Testing</a><ul>
<li><a href="#performance-evaluation">Performance Evaluation</a><ul>
<li><a href="#configuration-file">Configuration File</a></li>
<li><a href="#command-line">Command Line</a></li>
</ul>
</li>
<li><a href="#accuracy-validation">Accuracy Validation</a><ul>
<li><a href="#the-pulse-generator-utility">The pulse-generator Utility</a></li>
<li><a href="#the-interrupt-timer-utility">The interrupt-timer Utility</a></li>
<li><a href="#normaldistribparams-utility">The NormalDistribParams Utility</a></li>
<li><a href="#testing-accuracy">Testing Accuracy</a><ul>
<li><a href="#test-setup">Test Setup</a></li>
<li><a href="#test-results">Test Results</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="uses"></a>
Uses</h1>
<p>The pps-client source code is the reference design and proof of concept for a general technique that provides high accuracy timekeeping. It was implemented on a relatively slow ARM processor which should illustrate that a similar software solution can be successful on almost any application processor.</p>
<p>Although the goal of high accuracy computer timekeeping, evident from even a cursory search on the internet, has been around since at least the introduction of the Network Time Protocol, general support for high precision timekeeping over the internet is still not available. However, GPS reception is available everywhere and in conjunction with a daemon like pps-client can be used for that purpose now. Indeed, an internet search found commercial GPS repeaters that can bring GPS reception indoors with local coverage up to at least 30 meters.</p>
<p>The ability to time synchronize multiple computers with microsecond accuracy is particularly important for small embedded processors like the RPi that can be used to used to construct distributed systems with a large number of individual cores. This works very well when the individual RPis are time synchronized because that makes applications possible that would otherwise be difficult or impractical. One example is a multiple video camera system that synchronizes the video frames from the individual RPis each handling a different camera. In this kind of application a robot with twin cameras for eyes could easily synchronize the cameras from the system time on each RPi.</p>
<p>There are other uses for time synchronized computers: Network administrators would find it useful to have the possibility of making one-way, single-path time measurements of network delays. That becomes possible if the computers at the endpoints are accurately synchronized to GPS time - which is rarely the case at present. Also, certain kinds of scientific applications require accurate synchronization to an external clock. One sometimes of interest to amateur astronomers is <a href="https://en.wikipedia.org/wiki/Occultation">occultation timing</a>. Another is collection of distributed seismic data in the study of earthquakes or for substratum mapping. There are many others.</p>
<h1><a class="anchor" id="achieving-high-accuracy-timekeeping"></a>
Achieving High Accuracy Timekeeping</h1>
<p>The pps-client daemon is implemented as a <a href="https://en.wikipedia.org/wiki/PID_controller">proportional-integral (PI) controller</a> (a.k.a. type 2 Servo) with proportional and integral feedback provided each second but with the value of the integral feedback adjusted once per minute. The PI controller model provides a view of time synchronization as a linear feedback system in which gain coefficients can be adjusted to provide a good compromise among stability, transient response and amount of noise introduced in the error signal.</p>
<p>The error signal is the time difference between the one-second interval provided by a PPS signal and the length of the second reported by the system clock. The noise of concern is the second-to-second variation in time reported by the system because of the corresponding variation of system delay in responding to the PPS interrupt. This variable component of the delay, referred to as jitter, is a combination of clock oscillator jitter, PPS signal jitter and system latency in responding the the interrupt.</p>
<p>Because the error signal has jitter and is being used to control synchronization, the jitter component has the effect of a false error signal that causes the time and frequency synchronization to fluctuate as the controller attempts to follow the jitter. The conventional approach to reducing jitter is to low-pass or median filter the error signal. But filtering has the serious disadvantage that reduction of the jitter must be traded off against time delay introduced by the filter. Additional time delay in the feedback loop inevitably degrades controller performance. The pps-client program uses a much better technique that introduces no delay. To reduce the jitter, the time values returned by the system are passed through a hard limiter that clips extreme values before applying them as time corrections.</p>
<p>In fact, the individual time corrections constitute jitter added to a very small time correction. Consequently, each individual correction is mostly jitter and thus is wrong by nearly the amount that it deviates from zero. Because of that, the limiting employed in this system clips the maximum time corrections when the controller has fully stabilized to the time resolution of the system clock which is 1 microsecond.</p>
<p>It might seem that such extreme limiting would remove the desired error signal along with the noise. But that doesn't happen because the true time error is a slowly varying quasi-stationary (DC) level. Limiting only slices off the dynamic (AC) component of the error signal. The DC component remains. (To see what limiting does see Figures 3, 4, and 5 and the relevant discussion.) If the jitter were not limited, the controller would make the sum of the positive and negative jitter zero. That would be undesirable even after filtering because the noise has significant components in time periods that extend to well beyond one minute. Filtering would remove noise only for time intervals within the cut-off region of the filter. Longer period noise would remain.</p>
<p>On the other hand, instead of zeroing the sum of negative and positive jitter and thereby allowing the difference to be introduced as noise, once the controller has acquired, hard limiting causes the controller to make the number of positive and negative excursions to be equal around zero. That happens because the clipped positive and negative amplitudes are identical (1 microsecond). Thus, making the sum zero makes the count equal. As a result, the varying magnitude of the jitter around the control point is ignored and the reported time delay of the PPS rising edge adjusts to its median value, i.e., the delay at which there were as many shorter as longer reported delays over the previous minute.</p>
<p>The only disadvantage of hard limiting is that it reduces the amount of time correction that can be applied each each second. But that limitation is easily circumvented by allowing the hard limit level to track the amount of required time correction. This insures that the hard limit level does not prevent larger time corrections when they are necessary.</p>
<p>As described, hard limiting removes the error that would be introduced by the magnitude of jitter around the control point. However noise that is outside the control region of the controller, that is, noise with a period appreciably longer than one minute would remain. The time delay corresponding to PPS interrupt latency contains noise of that kind which appears as a slow variation in the latency which changes with processor activity. This latency is compensated in pps-client by a variable called <code>sysDelay</code>. The <code>sysDelay</code> value directly determines the control point of the controller because the time of the rollover of the second is determined as the reported time of the interrupt minus the value of <code>sysDelay</code>.</p>
<h2><a class="anchor" id="noise"></a>
Noise</h2>
<p>The situation with regard to jitter and latency (noise) in the PPS interrupt response is complicated. Not only is it necessary to characterize <code>sysDelay</code> but also noise must be removed as much as possible. In order to characterize <code>sysDelay</code>, measurements of interrupt latency were made by timing the triggering of the hardware interrupt from a GPIO pin tied across to the GPIO pin that requested the interrupt. Those measurements revealed that interrupt latency has three distinct components:</p>
<ol type="1">
<li>a constant component corresponding to the minimum time required to process the interrupt interrupt request,</li>
<li>an approximately Gaussian random component introduced by random jitter partially in interrupt response but predominantly <a href="https://en.wikipedia.org/wiki/Flicker_noise">flicker noise</a> in the system clock oscillator and</li>
<li>sporadically occurring "spikes" of long duration latency.</li>
</ol>
<p>The constant and average random components of interrupt latency completely characterize <code>sysDelay</code> and are determined by incorporating the interrupt latency measurement into the pps-client software. The pps-client driver that records the reception time of a PPS interrupt also has the ability to measure the initiation and reception times of a test interrupt triggered across a pair of GPIO pins. The time difference in those is used to determine the PPS interrupt latency for a particular RPi and Linux kernel. The median of the latency measurement then becomes the applied <code>sysDelay</code> value. This cancels the median of the delay from the PPS rising edge generated by the hard limiting in the controller.</p>
<p>The long duration latency of component 3 is treated as <a href="#jitter-spikes">noise that is to be removed</a>.</p>
<h3><a class="anchor" id="raspberry-pi-2"></a>
Raspberry Pi 2</h3>
<p>Although qualitatively similar, the quantitative noise characteristics of Raspberry Pi 2 and Raspberry Pi 3 are different. Raspberry Pi 3 noise is described in a <a href="#raspberry-pi-3">separate section</a>. Typical Raspberry Pi 2 PPS delay noise (jitter) is shown in Figure 1a.</p>
<p><a class="anchor" id="timed-event"></a> </p><div class="image">
<img src="pps-jitter-distrib.png" alt="pps-jitter-distrib.png"/>
<div class="caption">
Raspberry Pi 2 Jitter Distribution</div></div>
<p>Figure 1a is data that was captured from an RPi 2 (BCM2836 processor) test unit over 24 hours to the file <code>/var/local/pps-jitter-distrib</code> by setting <code>jitter-distrib=enable</code> in <code>/etc/pps-client.conf</code> and is typical data that is easily generated on any RPi 2.</p>
<p>Figure 1a shows a delay peak at zero (relative to <code>sysDelay</code>) followed by infrequent sporadic interrupt delays in the log plot. These delays are caused by other processes running in the Linux kernel. Even though pps-client is a real-time process, the PPS interrupt does not always receive an immediate response. The situation is much better on the Linux 4 kernel than on previous kernels. On real-time configured Linux 3 kernels <code>sysDelay</code> was on the order of 25 μsecs. On the stock Linux 4 kernel <code>sysDelay</code> has shrunk to about 9 μsecs on Raspberry Pi 2. But delays caused by other running processes continue to be a problem. Clearly, the pps-client controller can <a href="InterruptTimerDistrib.png">synchronize the time precisely</a>. Evidently, the most significant impediment to precisely timing external events is sporadic Linux kernel interrupt latency.</p>
<p>The random noise component at zero in Figure 1a is a combination of randomness in the response time of the system to the PPS interrupt and flicker noise in the clock oscillator. These random components can be evaluated by comparing the jitter distribution in Figure 1a to the test interrupt delay distribution collected over the same 24 hour period.</p>
<div class="image">
<img src="interrupt-delay-comparison.png" alt="interrupt-delay-comparison.png"/>
<div class="caption">
Test Interrupt and PPS Interrupt Delay Comparison</div></div>
<p> The Test Interrupt Delay distribution was captured in the file <code>/var/local/pps-intrpt-distrib</code> by setting <code>interrupt-distrib=enable</code> in <code>/etc/pps-client.conf</code>.</p>
<p>The two different random components are inseparable in the jitter distribution (displayed in the Figure 1b as PPS Interrupt Delay). However, the jitter distribution can be compared with the Test Interrupt Delay distribution (TID). The TID is a system response to a self-generated interrupt that is measured totally within the system. That makes it blind to flicker noise in the system clock oscillator. Consequently, it is representative of the randomness in the system response to an interrupt that is also present in the jitter. It shows a distribution with a standard deviation (SD) of about 0.82 microsecond. This was data collected while <code>sysDelay</code> took on the value of 8 μsecs with 45,343 samples collected.</p>
<p>In comparison, the PPS Interrupt Delay distribution SD is estimated to be about 0.92 microseconds in Figure 1b.</p>
<p>Since distribution SDs of this kind add in root-sum-square fashion,</p>
<center><em>σ<sub> t</sub></em><sup> 2</sup> = <em>σ</em><sub> 1</sub><sup> 2</sup> + <em>σ</em><sub> 2</sub><sup> 2</sup></center><p>then by using the numbers above with <em>σ<sub> t</sub></em> = 0.92 the width of the PPS delay distribution and <em>σ</em><sub> 1</sub> = 0.82 the width of the test interrupt distribution, the flicker noise SD, <em>σ</em><sub> 2</sub>, is calculated to be about 0.42 microsecond which shows the random noise to be dominated by random jitter in the interrupt response for Pi 2.</p>
<h3><a class="anchor" id="raspberry-pi-3"></a>
Raspberry Pi 3</h3>
<p>Typical Raspberry Pi 3 PPS delay noise (jitter) is shown in Figure 2a.</p>
<div class="image">
<img src="pps-jitter-distrib-RPi3.png" alt="pps-jitter-distrib-RPi3.png"/>
<div class="caption">
Raspberry Pi 3 Jitter Distribution</div></div>
<p> Figure 2a is data that was captured from an RPi 3 test unit over 24 hours to the file <code>/var/local/pps-jitter-distrib</code> by setting <code>jitter-distrib=enable</code> in <code>/etc/pps-client.conf</code> and is typical data that is easily generated on any RPi 3.</p>
<p>The random component of the jitter is estimated to have about 0.83 μsecs SD in Figure 2a. The sporadic system interrupt delays in the log plot did not extend beyond 18 μsecs in this 24 hours test period. There were 480 of these out of 86,400 accounting for only about one half of one percent of the total samples.</p>
<p>The random component at zero in Figure 2a was expected to be a combination of randomness in the response time of the system to the PPS interrupt and flicker noise in the clock oscillator. This hypothesis was tested by comparing the jitter distribution in Figure 2a to the test interrupt delay distribution collected over the same 24 hour period.</p>
<div class="image">
<img src="interrupt-delay-comparison-RPi3.png" alt="interrupt-delay-comparison-RPi3.png"/>
<div class="caption">
Test Interrupt and PPS Interrupt Delay Comparison</div></div>
<p> The Test Interrupt Delay distribution was captured in the file <code>/var/local/pps-intrpt-distrib</code> by setting <code>interrupt-distrib=enable</code> in <code>/etc/pps-client.conf</code>.</p>
<p>As Figure 2b shows, the TID is much narrower for this typical Raspberry Pi 3 in comparison with Pi 2. It shows a distribution with a standard deviation (SD) of about 0.37 microsecond. This was data collected while sysDelay took on the value of 5 μsecs with 50,212 samples collected.</p>
<p>Using the same calculation that was done for RPi 2, with <em>σ<sub> t</sub></em> = 0.83 the width of the PPS delay distribution and <em>σ</em><sub> 1</sub> = 0.37 the width of the test interrupt distribution, the flicker noise SD, <em>σ</em><sub> 2</sub>, is calculated to be about 0.74 microsecond showing flicker noise and PPS jitter to be the dominant component of the random jitter for Pi 3. To within estimation errors this is typical of the Pi 3 units that were tested.</p>
<h3><a class="anchor" id="jitter-spikes"></a>
Jitter Spikes</h3>
<p>A typical jitter spike is evident in the pps-client status printout shown below which shows low jitter values except for the delay spike in the middle line of the image.</p>
<div class="image">
<img src="jitter-spike.png" alt="jitter-spike.png"/>
<div class="caption">
Jitter Spike in Status Printout</div></div>
<p> Since jitter spikes are easily identified by the length of delay, they are removed by suspending controller time and frequency updating when delay duration exceeds the controller <code>noiseLevel</code> value mentioned above.</p>
<h1><a class="anchor" id="the-pps-client-controller"></a>
The pps-client Controller</h1>
<p>With the discussion above as background, the sections below provide a cross-referenced summary of the source code. While Doxygen does a credible job of cross-referencing, this summary probably only makes sense while referencing a side-by-side open copy of the source code set up as a project in a cross-referencing editor like <a href="http://www.eclipse.org/cdt/">Eclipse</a>.</p>
<p>The pps-client controller can be thought of as consisting of two conceptual components, a feedback controller and a feedforward compensator.</p>
<h2><a class="anchor" id="feedback-controller"></a>
Feedback Controller</h2>
<p>The pps-client controller algorithm processes timestamps of interrupts from a hardware GPIO pin triggered by the rising edges of a PPS signal. These PPS timestamps are recorded by a kernel device driver, <code>pps-client.ko</code>, that was specifically designed to record the timestamps as closely as possible to when the processor responded to the PPS interrupts. This is important because the time at which the system responded to the interrupt minus the time at which it actually toggled the input pin is the interrupt delay that must be compensated by the control point constant, <code><a class="el" href="dc/d1d/struct_g.html#a10977d4736db79fc764722287a83f579">G.sysDelay</a></code>, and this delay must correspond as accurately as possible to that time difference in order to reduce the uncertainty of the delay value.</p>
<p>The <code><a class="el" href="d5/d60/pps-client_8cpp.html#a27417d63efafbd4125276332f55a4347">makeTimeCorrection()</a></code> routine is the central controller routine and it waits in the timer loop, <code><a class="el" href="d5/d60/pps-client_8cpp.html#a4b3bdab744bd7ed860326323fad180f2">waitForPPS()</a></code> inside the <code><a class="el" href="d5/d60/pps-client_8cpp.html#a4610ca59593e517fde46aa10657a7891">readPPS_SetTime()</a></code> routine, until a PPS timestamp becomes available from the pps-client device driver. At that instant the timestamp is passed into <code><a class="el" href="d5/d60/pps-client_8cpp.html#a27417d63efafbd4125276332f55a4347">makeTimeCorrection()</a></code> where the fractional part of the second becomes available as the variable <code><a class="el" href="dc/d1d/struct_g.html#ae293468b29e54f862f128d7936dc710e" title="Fractional second part of G.t received from pps-client device driver. ">G.interruptTime</a></code> which is converted to the controller error variable as,</p>
<p><a class="el" href="dc/d1d/struct_g.html#a4a3835b313753b01f4b02cd95a7355a1" title="Set equal to G.interruptTime - G.sysDelay in makeTimeCorrection(). ">G.rawError</a> = <a class="el" href="dc/d1d/struct_g.html#ae293468b29e54f862f128d7936dc710e" title="Fractional second part of G.t received from pps-client device driver. ">G.interruptTime</a> - <a class="el" href="dc/d1d/struct_g.html#a10977d4736db79fc764722287a83f579">G.sysDelay</a></p>
<p>Each <code><a class="el" href="dc/d1d/struct_g.html#a4a3835b313753b01f4b02cd95a7355a1" title="Set equal to G.interruptTime - G.sysDelay in makeTimeCorrection(). ">G.rawError</a></code> is a time measurement corrupted by jitter. Thus the value of <code><a class="el" href="dc/d1d/struct_g.html#a4a3835b313753b01f4b02cd95a7355a1" title="Set equal to G.interruptTime - G.sysDelay in makeTimeCorrection(). ">G.rawError</a></code> generated each second can be significantly different from the true time correction. To extract the time correction, <code><a class="el" href="dc/d1d/struct_g.html#a4a3835b313753b01f4b02cd95a7355a1" title="Set equal to G.interruptTime - G.sysDelay in makeTimeCorrection(). ">G.rawError</a></code> is passed into the <code><a class="el" href="d5/d60/pps-client_8cpp.html#ad71923ccec11a6d6e132c43e60fe8765">removeNoise()</a></code> routine that contains the first noise processing routine, <code><a class="el" href="d5/d60/pps-client_8cpp.html#a0b30b41495a6426b5bb557ced936901b">detectDelaySpike()</a></code>, that determines (when <code><a class="el" href="dc/d1d/struct_g.html#a4a3835b313753b01f4b02cd95a7355a1" title="Set equal to G.interruptTime - G.sysDelay in makeTimeCorrection(). ">G.rawError</a></code> is sufficiently small) is <code><a class="el" href="dc/d1d/struct_g.html#a4a3835b313753b01f4b02cd95a7355a1" title="Set equal to G.interruptTime - G.sysDelay in makeTimeCorrection(). ">G.rawError</a></code> spike noise? in which case further processing in the current second is skipped. If it's not spike noise, the average time slew, <code><a class="el" href="dc/d1d/struct_g.html#abdf7a123f53d89c6fd66037a5a31a5fe" title="Average slew value detemined by getTimeSlew() from the average of G.slewAccum each time G...">G.avgSlew</a></code> is updated by <code><a class="el" href="dc/d1d/struct_g.html#a4a3835b313753b01f4b02cd95a7355a1" title="Set equal to G.interruptTime - G.sysDelay in makeTimeCorrection(). ">G.rawError</a></code>. The <code><a class="el" href="dc/d1d/struct_g.html#abdf7a123f53d89c6fd66037a5a31a5fe" title="Average slew value detemined by getTimeSlew() from the average of G.slewAccum each time G...">G.avgSlew</a></code> value along with the average time correction up to the current second, <code><a class="el" href="dc/d1d/struct_g.html#a02413e548b7a371334100547ed4dc409" title="A one-minute rolling average of G.timeCorrection values generated by getAverageCorrection(). ">G.avgCorrection</a></code>, determines the current hard limit value that will be applied in the final noise removal routine, <code><a class="el" href="d5/d60/pps-client_8cpp.html#a5443ab59528135706e70991cf1f880d2">clampJitter()</a></code>. Then <code><a class="el" href="dc/d1d/struct_g.html#a4a3835b313753b01f4b02cd95a7355a1" title="Set equal to G.interruptTime - G.sysDelay in makeTimeCorrection(). ">G.rawError</a></code> limited by <code><a class="el" href="d5/d60/pps-client_8cpp.html#a5443ab59528135706e70991cf1f880d2">clampJitter()</a></code> is returned from <code><a class="el" href="d5/d60/pps-client_8cpp.html#ad71923ccec11a6d6e132c43e60fe8765">removeNoise()</a></code> as <code><a class="el" href="dc/d1d/struct_g.html#aa9bd4f66282b63032fb56f18fa0ab1c6" title="The controller error resulting from removing jitter noise from G.rawError in removeNoise(). ">G.zeroError</a></code> which is then modified by the proportional gain value and then sign reversed to generate <code><a class="el" href="dc/d1d/struct_g.html#ace22931e6eb849c1f7c5c72bd0f6bdd0" title="Time correction value constructed in makeTimeCorrection() by dividing G.zeroError by G...">G.timeCorrection</a></code> for the current second.</p>
<p>The sign reversal on <code><a class="el" href="dc/d1d/struct_g.html#ace22931e6eb849c1f7c5c72bd0f6bdd0" title="Time correction value constructed in makeTimeCorrection() by dividing G.zeroError by G...">G.timeCorrection</a></code> is necessary in order to provide a proportional control step that subtracts the time correction from the current time slew, making a time slew that is too large smaller and vice versa. That happens by passing <code><a class="el" href="dc/d1d/struct_g.html#ace22931e6eb849c1f7c5c72bd0f6bdd0" title="Time correction value constructed in makeTimeCorrection() by dividing G.zeroError by G...">G.timeCorrection</a></code> to the system <code><a class="el" href="d5/d60/pps-client_8cpp.html#a4efd2ecedb34b38cd1000d86ba5f6ef9">adjtimex()</a></code> routine which slews the time by exactly that value unless the magnitude is greater than about 500 μsecs, in which case the slew adjustment is restricted to 500 μsecs by <code><a class="el" href="d5/d60/pps-client_8cpp.html#a4efd2ecedb34b38cd1000d86ba5f6ef9">adjtimex()</a></code>. This is usually what happens when pps-client starts. After several minutes of 500 μsec steps, <code><a class="el" href="dc/d1d/struct_g.html#ace22931e6eb849c1f7c5c72bd0f6bdd0" title="Time correction value constructed in makeTimeCorrection() by dividing G.zeroError by G...">G.timeCorrection</a></code> will be in a range to allow the integral control step to begin.</p>
<p>But before the integral control step can begin, an average of the second-by-second time corrections over the previous minute must be available to form the integral. That average is constructed in the <code><a class="el" href="d5/d60/pps-client_8cpp.html#a062748b2a1af5a7bb4e0efd94b84f8d1">getAverageCorrection()</a></code> routine which sequences the time corrections through a circular buffer <code><a class="el" href="dc/d1d/struct_g.html#a37353318dc80234a14c520f5d7f0c030" title="Contains the G.timeCorrection values from over the previous 60 seconds. ">G.correctionFifo</a></code> and simultaneously generates a rolling sum in <code><a class="el" href="dc/d1d/struct_g.html#a575ac93c798155d0daab255acb63e534" title="Accumulates G.timeCorrection values from G.correctionFifo in getAverageCorrection() in order to gener...">G.correctionAccum</a></code> which is scaled to form a rolling average of time corrections that is returned as <code><a class="el" href="dc/d1d/struct_g.html#a02413e548b7a371334100547ed4dc409" title="A one-minute rolling average of G.timeCorrection values generated by getAverageCorrection(). ">G.avgCorrection</a></code> by <code><a class="el" href="d5/d60/pps-client_8cpp.html#a062748b2a1af5a7bb4e0efd94b84f8d1">getAverageCorrection()</a></code> each second. At feedback convergence, the rolling sum of <em>unit</em> <code><a class="el" href="dc/d1d/struct_g.html#ace22931e6eb849c1f7c5c72bd0f6bdd0" title="Time correction value constructed in makeTimeCorrection() by dividing G.zeroError by G...">G.timeCorrection</a></code> values makes <code><a class="el" href="dc/d1d/struct_g.html#a02413e548b7a371334100547ed4dc409" title="A one-minute rolling average of G.timeCorrection values generated by getAverageCorrection(). ">G.avgCorrection</a></code> the <em>median</em> of <code><a class="el" href="dc/d1d/struct_g.html#ace22931e6eb849c1f7c5c72bd0f6bdd0" title="Time correction value constructed in makeTimeCorrection() by dividing G.zeroError by G...">G.timeCorrection</a></code> values.</p>
<p>At the end of each minute the integral control step in the <code><a class="el" href="d5/d60/pps-client_8cpp.html#aec269fd5b44aeaa993781dddc42a2b59">makeAverageIntegral()</a></code> routine sums <code><a class="el" href="dc/d1d/struct_g.html#a02413e548b7a371334100547ed4dc409" title="A one-minute rolling average of G.timeCorrection values generated by getAverageCorrection(). ">G.avgCorrection</a></code> into one of 10 accumulators <code><a class="el" href="dc/d1d/struct_g.html#a5e85549963c557372ae2551b9d62b48a" title="Array of integrals constructed by makeAverageIntegral(). ">G.integral</a>[i]</code> each of which accumulates a separate integral that is offset by one second from the others. At the end of the minute those are averaged into <code><a class="el" href="dc/d1d/struct_g.html#a62a2f5f7f6337aad5c3606b501c570df" title="One-minute average of the integrals in G.integral[]. ">G.avgIntegral</a></code>.</p>
<p>Also at the end of the minute (actually after 60 time corrections have been averaged as determined by <code><a class="el" href="d5/d60/pps-client_8cpp.html#a2a7a8a06f0119359f624d891dbcfa08f">integralIsReady()</a></code>), <code><a class="el" href="dc/d1d/struct_g.html#a62a2f5f7f6337aad5c3606b501c570df" title="One-minute average of the integrals in G.integral[]. ">G.avgIntegral</a></code> is returned from <code><a class="el" href="d5/d60/pps-client_8cpp.html#a8696238d80e8a7a4ae44de6de50ab1ce">getIntegral()</a></code> and multiplied by <code><a class="el" href="dc/d1d/struct_g.html#a309b5f007032df71d365a08fe748651a" title="Controller integral gain. ">G.integralGain</a></code> to create <code><a class="el" href="dc/d1d/struct_g.html#aad06e2bf495eba586f2ed7df740b1c8e" title="System clock frequency correction calculated as G.integralTimeCorrection * G.integralGain. ">G.freqOffset</a></code> which, after scaling by <code>ADJTIMEX_SCALE</code> that is required by <code><a class="el" href="d5/d60/pps-client_8cpp.html#a4efd2ecedb34b38cd1000d86ba5f6ef9">adjtimex()</a></code>, is passed to <code><a class="el" href="d5/d60/pps-client_8cpp.html#a4efd2ecedb34b38cd1000d86ba5f6ef9">adjtimex()</a></code> to provide the integral control.</p>
<h2><a class="anchor" id="feedforward-compensator"></a>
Feedforward Compensator</h2>
<p>The specific purpose of the feedback controller described above is to adjust the system time second by second to satisfy this local "equation of time":</p>
<p>0 = median(<a class="el" href="dc/d1d/struct_g.html#ae293468b29e54f862f128d7936dc710e" title="Fractional second part of G.t received from pps-client device driver. ">G.interruptTime</a>) - <a class="el" href="dc/d1d/struct_g.html#a10977d4736db79fc764722287a83f579">G.sysDelay</a></p>
<p>It does that by setting the local clock so that the difference between <code><a class="el" href="dc/d1d/struct_g.html#a10977d4736db79fc764722287a83f579">G.sysDelay</a></code> and the median of <code><a class="el" href="dc/d1d/struct_g.html#ae293468b29e54f862f128d7936dc710e" title="Fractional second part of G.t received from pps-client device driver. ">G.interruptTime</a></code> is zero. For this to succeed in adjusting the local time to the PPS, <code><a class="el" href="dc/d1d/struct_g.html#a10977d4736db79fc764722287a83f579">G.sysDelay</a></code> must be the median of the time delay at which the system responded to the rising edge of the PPS interrupt. But the median value of <code><a class="el" href="dc/d1d/struct_g.html#a10977d4736db79fc764722287a83f579">G.sysDelay</a></code> can't be determined by the feedback controller. As indicated by the equation, all the controller can do is satisfy the equation of time.</p>
<p>In order to independently determine the <code><a class="el" href="dc/d1d/struct_g.html#a10977d4736db79fc764722287a83f579">G.sysDelay</a></code> value, a calibration interrupt is made every second immediately following the PPS interrupt. These time measurements are requested from the <code>pps-client.ko</code> device driver in the <code><a class="el" href="d5/d60/pps-client_8cpp.html#a8a87b6ef0bf407467331509efdd5b3e9">getInterruptDelay()</a></code> routine. That routine calculates <code><a class="el" href="dc/d1d/struct_g.html#a5d37c911a8f0223b4b1437107c61fe22" title="Value of the interrupt delay calibration measurement received from the pps-client device driver...">G.intrptDelay</a></code> from the time measurements and calls <code><a class="el" href="d5/d60/pps-client_8cpp.html#abfab868ee3b041247625234432820321">removeIntrptNoise()</a></code> with that value. The <code><a class="el" href="d5/d60/pps-client_8cpp.html#abfab868ee3b041247625234432820321">removeIntrptNoise()</a></code> routine generates <code><a class="el" href="dc/d1d/struct_g.html#a65950b4e65266e48eacd49d350809df4" title="Median of G.intrptDelay values calculated in getInterruptDelay(). ">G.delayMedian</a></code>, an estimate of the median of the <code><a class="el" href="dc/d1d/struct_g.html#a5d37c911a8f0223b4b1437107c61fe22" title="Value of the interrupt delay calibration measurement received from the pps-client device driver...">G.intrptDelay</a></code> value, in a parallel way and using the same routines that <code><a class="el" href="d5/d60/pps-client_8cpp.html#ad71923ccec11a6d6e132c43e60fe8765">removeNoise()</a></code> uses to generate the median of <code><a class="el" href="dc/d1d/struct_g.html#ae293468b29e54f862f128d7936dc710e" title="Fractional second part of G.t received from pps-client device driver. ">G.interruptTime</a></code>. The <code><a class="el" href="dc/d1d/struct_g.html#a65950b4e65266e48eacd49d350809df4" title="Median of G.intrptDelay values calculated in getInterruptDelay(). ">G.delayMedian</a></code> value is then assigned to <code><a class="el" href="dc/d1d/struct_g.html#a10977d4736db79fc764722287a83f579">G.sysDelay</a></code>.</p>
<h2><a class="anchor" id="controller-behavior-on-startup"></a>
Controller Behavior on Startup</h2>
<p>Figure 3 shows the behavior of the controller when pps-client is started. The figure shows frequency offset and corresponding time corrections recorded to <code>/etc/local/pps-offsets</code> when saving this file is requested from the <a href="#command-line">command line</a> as <code>pps-offsets</code>.</p>
<p>During the first 120 seconds (not shown in the figure), the controller made time corrections to get the time offset into a reasonable range but made no frequency corrections. Frequency offset correction was enabled at sequence number (second) 120. Over the next 600 seconds the pps-client controller adjusted the frequency offset to bring the system clock frequency into sync with the PPS.</p>
<div class="image">
<img src="pps-offsets-to-720.png" alt="pps-offsets-to-720.png"/>
<div class="caption">
Offsets to 720 secs</div></div>
<p> The expanded view of the same data over the first 300 seconds in Figure 4 shows in more detail what is happening. In general, proportional feedback is correcting the time by the (gain-scaled and limited) time error measured each second. The integral feedback is updated each minute with the average of the time corrections over the previous minute. As the integral is formed the result is to move the frequency offset minute by minute towards synchronization. It should be clear that in any minute where the system clock frequency is not perfectly in sync with the PPS, the average length of the second will be either longer or shorter than one second. For example, if the average length of the second differed by 1 microsecond from the true length of the second, that would indicate that the system clock was in error by 1 part per million, in which case an adjustment of the frequency offset by 1 ppm might be expected.</p>
<div class="image">
<img src="pps-offsets-to-300.png" alt="pps-offsets-to-300.png"/>
<div class="caption">
Offsets to 300 secs</div></div>
<p> Now notice that, in the minute between sequence number 120 and 180, there is a clearly visible positive bias in the time correction values. Averaging those time corrections (literally adding them from the figure and dividing by 60), gets a 3.22 microsecond average bias indicating that the system clock is in error by 3.22 parts per million over that minute. However, in the next minute (between 180 and 240), the frequency offset is changed by only about 1.8 ppm. In other words, frequency offset change is only about 0.55 of the amount needed to do a full frequency correction and, moreover, it is easily verified that same fractional correction is made in every succeeding minute.</p>
<p>The 0.55 fractional adjustment is the damping ratio fixed by the integral gain of the PI controller. That damping value has been chosen to keep the loop stable and, in fact, to set it below the maximum acquire rate provided by a ratio of 1 which corresponds to the full frequency correction.</p>
<p>But why not apply the full frequency correction each second? The reason is that the correction is always made too late. It would have been correct for the minute in which it was measured but by the time it has been measured it can only be an estimate for the next minute. If the estimate is even slightly too large then the estimation error will be integrated along with the estimate and will become progressively larger in each succeeding minute until the result is an oscillation of the frequency around its stable value. The design decision is that, considering noise and other system uncertainties, it is better to have the controller acquire more slowly with a lower damping value than to risk oscillation with a higher value.</p>
<p>Once the controller has acquired, it continues to average the time errors that occurred over the past minute and to apply the scaled integral of the average as the frequency correction for the next minute. So theoretically the controller never acquires. Rather it is constantly chasing the value to be acquired with a somewhat low estimate of that value. This seems to argue for a <a href="https://en.wikipedia.org/wiki/Zeno%27s_paradoxes">Zeno's paradox</a>. In practice, however, the difference between the estimate and the target value soon drops below the noise level so that any practical measurement would indicate that the controller had, indeed, acquired.</p>
<p>The startup transient in Figure 3 is the largest adjustment in frequency the controller ever needs to make and in order to make that adjustment relatively large time corrections are necessary. Once the control loop has acquired, however, then by design the time corrections will exceed 1 microsecond only when the controller must make larger than expected frequency offset corrections. In that case, the controller will simply adjust to larger corrections by raising its hard limit level.</p>
<h2><a class="anchor" id="performance-under-stress"></a>
Performance Under Stress</h2>
<p>To get some idea of what the worst case corrections might be, Figure 5 demonstrates how the pps-client control loop responds to stress. In this case a full processor load (100% usage on all four cores) was suddenly applied at sequence number 1900. The loading raised the processor temperature causing a total shift in frequency offset of about 1.7 ppm from onset to a stable value near sequence number 2500. The time corrections increased to 2 microseconds only in the region of steepest ascent. Since the transients caused by extreme load changes occur infrequently, it is likely that a time correction more than 1 microsecond would only occasionally occur in normal operation. Moreover it is unlikely that a precision time measurement would be required simultaneously with the onset of full processor load.</p>
<div class="image">
<img src="pps-offsets-stress.png" alt="pps-offsets-stress.png"/>
<div class="caption">
PPS offsets to Stress</div></div>
 <h2><a class="anchor" id="error-handling"></a>
Error Handling</h2>
<p>All trapped errors are reported to the log file <code>/var/log/pps-client.log</code>. In addition to the usual suspects, pps-client also reports interrupt dropouts. Also because sustained dropouts may indicate a fault with the PPS source, there is a provision to allow hardware enunciation of PPS dropouts. Setting the configuration option <code>alert-pps-lost=enable</code> will cause RPi GPIO header pin 15 to go to a logic HIGH on loss of the PPS interrupt and to return to a logic LOW when the interrupt resumes.</p>
<h1><a class="anchor" id="testing"></a>
Testing</h1>
<p>Before performing any test, make sure that the test environment is clean. At a minimum, if not starting fresh, <b>reboot the <code>RPi</code>s that are being used in the tests</b>. This can eliminate a lot of unexpected problems.</p>
<p>The simplest test is to run pps-client and verify with the status printout that the controller locks to the PPS signal to a precision of one microsecond. From a terminal, that can be done at any time while pps-client is running with, </p><pre class="fragment">$ pps-client -v
</pre><p>That runs a secondary copy of pps-client that just displays a status printout that the pps-client daemon continuously generates. When pps-client starts up you can expect to see something like the following in the status printout:</p>
<div class="image">
<img src="StatusPrintoutOnStart.png" alt="StatusPrintoutOnStart.png"/>
<div class="caption">
Status Printout on Startup</div></div>
<p> The <code>jitter</code> value is showing the fractional second offset of the PPS signal according to the system clock. That value will decrease second by second as the controller locks to the PPS signal. After about 10 minutes the status printout will look like this:</p>
<div class="image">
<img src="StatusPrintoutAt10Min.png" alt="StatusPrintoutAt10Min.png"/>
<div class="caption">
Status Printout after 10 Min</div></div>
<p> The <code>jitter</code> is displaying small numbers. The time of the rising edge of the PPS signal is shown in the second column. The <code>clamp</code> value on the far right indicates that the maximum time correction applied to the system clock is being limited to one microsecond. The system clock is synchronized to the PPS signal to a precision of one microsecond.</p>
<p>It can take as long as 20 minutes for pps-client to fully acquire the first time it runs. This happens if the <code>jitter</code> shown in the status printout is on the order of 100,000 microseconds or more. It's quite common for the NTP fractional second to be off by that amount. In this case pps-client may restart several times as it slowly reduces the <code>jitter</code> offset. That happens because the system function <code><a class="el" href="d5/d60/pps-client_8cpp.html#a4efd2ecedb34b38cd1000d86ba5f6ef9">adjtimex()</a></code> that pps-client calls internally prevents time changes of more than about 500 microseconds each second.</p>
<p>Here are the parameters shown in the status printout:</p>
<ul>
<li>First two columns - date and time of the rising edge of the PPS signal.</li>
<li>Third column - the sequence number giving the total PPS interrupts received since pps-client was started.</li>
<li><code>jitter</code> - the time deviation in microseconds recorded at the reception of the PPS interrupt.</li>
<li><code>freqOffset</code> - the frequency offset of the system clock in parts per million of the system clock frequency.</li>
<li><code>avgCorrection</code> - the time corrections (in microseconds) averaged over the previous minute.</li>
<li><code>clamp</code> - the hard limit (in microsecs) applied to the raw time error to convert it to a time correction.</li>
</ul>
<p>Every sixth line, interrupt delay parameters are also shown. About every 17 minutes, an SNTP time query will be made and the results of that will be shown, but will have no effect unless a time update is required.</p>
<p>To stop the display type ctrl-c.</p>
<p>The pps-client daemon writes the timestamp and sequence number of the PPS rising edge to an in-memory file that changes every second. You can verify that the time is being controlled and that the controller is currently active by entering this a few times: </p><pre class="fragment">$ cat /run/shm/pps-assert
</pre><p>That would generate something like this: </p><pre class="fragment">pi@raspberrypi:~ $ cat /run/shm/pps-assert
1460044256.000001#173028
pi@raspberrypi:~ $ cat /run/shm/pps-assert
1460044259.000000#173031
</pre><p>The timestamp is displayed in seconds to the nearest microsecond. This is probably the most foolproof way of determining that pps-client is currently running. If you get the same numbers twice in succession or none at all you know it's not.</p>
<p>Another way to tell that pps-client is running is to get the process id with, </p><pre class="fragment">$ pidof pps-client
</pre><p>which will only return a PID if pps-client is an active process.</p>
<h2><a class="anchor" id="performance-evaluation"></a>
Performance Evaluation</h2>
<p>Data can be collected while pps-client is running either by setting specific data files to be saved in the pps-client configuration file or by requesting others from the command line of a terminal that is communicating with the RPi.</p>
<h3><a class="anchor" id="configuration-file"></a>
Configuration File</h3>
<p>Data that can be collected using the configuration file is enabled with settings in <code>/etc/pps-client.conf</code>. These instruct the pps-client daemon to generate data files, some of which provided the data used to generate the spreadsheet graphs shown on this page and in the project README file. Generating a particular file requires setting a flag. All of these files are disabled by default. But they can be enabled or disabled at any time, including while the pps-client daemon is running, by editing and saving the config file. Here are the flags you can use to enable them:</p>
<ul>
<li><code>error-distrib=enable</code> generates <code>/var/local/pps-error-distrib-forming</code> which contains the currently forming distribution of time corrections to the system clock. When 24 hours of corrections have been accumulated, these are transferred to <code>/var/local/pps-error-distrib</code> which contains the cumulative distribution of time corrections applied to the system clock over 24 hours.</li>
<li><code>jitter-distrib=enable</code> generates <code>/var/local/pps-jitter-distrib-forming</code> which contains the currently forming distribution of jitter values. When 24 hours of corrections have been accumulated, these are transferred to <code>/var/local/pps-jitter-distrib</code> which contains the cumulative distribution of all time (jitter) values recorded at reception of the PPS interrupt over 24 hours.</li>
<li><code>interrupt-distrib=enable</code> generates <code>/var/local/pps-intrpt-distrib-forming</code> which contains the currently forming distribution of calibration interrupt delays. When 24 hours of these have been accumulated they are transferred to <code>/var/local/pps-intrpt-distrib</code> which contains a cumulative distribution of recorded calibration interrupt delays that occurred over 24 hours.</li>
<li><code>sysdelay-distrib=enable</code> generates <code>/var/local/pps-sysDelay-distrib-forming</code> which contains the currently forming distribution of <code>sysDelay</code> values. When 24 hours of these have been accumulated they are transferred to <code>/var/local/pps-sysDelay-distrib</code> which contains a cumulative distribution of <code>sysDelay</code> values that were applied to the pps-client controller over 24 hours.</li>
</ul>
<p>Note that while the turnover interval for some of the files above is given as 24 hours, the interval will usually be slightly longer than 24 hours because pps-client runs on an internal count, <code><a class="el" href="dc/d1d/struct_g.html#a118f8fa500027b95904940749ca69e67" title="Advancing count of controller cycles once G.isAcquiring is &quot;true&quot;. ">G.activeCount</a></code>, that does not count lost PPS interrupts or skipped jitter spikes.</p>
<h3><a class="anchor" id="command-line"></a>
Command Line</h3>
<p>Some of the data that can be saved by a running pps-client daemon is of the on-demand type. This is enabled by executing pps-client with the <code>-s</code> flag while the daemon is running. For example, </p><pre class="fragment">$ pps-client -s frequency-vars
</pre><p>will return something like this </p><pre class="fragment">pps-client v1.1.0 is running.
Writing to default file: /var/local/pps-frequency-vars
</pre><p>You can write to a different filename or location by using the <code>-f</code> flag followed by the desired path and filename: </p><pre class="fragment">$ pps-client -s frequency-vars -f data/freq-vars-01.txt
</pre><p>The specified directories must already exist. You may also include the <code>-v</code> flag if you want the status display to start as soon as the requested file is written to disk.</p>
<p>As an aid to remembering what can be requested, omitting the type of data will print a list of what's available. Currently that would result in something like, </p><pre class="fragment">$ pps-client -s
pps-client v1.1.0 is running.
Error: Missing argument for -s.
Accepts any of these:
rawError
intrptError
frequency-vars
pps-offsets
</pre><p>described as,</p><ul>
<li><code>rawError</code> writes an exponentially decaying distribution of unprocessed PPS jitter values as they enter the controller. These are relative to the current value of <code>sysDelay</code>. Each jitter value that is added to the distribution has a half-life of one hour. So the distribution is almost completely refreshed every four to five hours.</li>
<li><code>intrptError</code> writes an exponentially decaying distribution of unprocessed test interrupt delay values. The description is otherwise the same as for <code>"rawError"</code>.</li>
<li><code>frequency-vars</code> writes the last 24 hours of clock frequency offset and Allan deviation of one-minute samples in each five-minute interval indexed by the timestamp at each interval.</li>
<li><code>pps-offsets</code> writes the previous 10 minutes of recorded time offsets and applied frequency offsets indexed by the sequence number (seq_num) each second.</li>
</ul>
<h2><a class="anchor" id="accuracy-validation"></a>
Accuracy Validation</h2>
<p>Time accuracy is defined as the absolute time error at any point in time relative to the PPS time clock. The limit to time accuracy on any processor that uses a conventional integrated circuit crystal oscillator is <a href="https://en.wikipedia.org/wiki/Flicker_noise">flicker noise</a> in the oscillator. At the 1 Hz operating frequency of the pps-client controller, flicker noise is evident as <a href="#noise">part of the random component</a> of second-to-second jitter. The integrator in the control loop removes it from the system clock frequency adjustment and the proportional adjustment only allows a 1 microsecond adjustment each second which ignores all but 1 microsecond of it.</p>
<p>As a result, any internal time measurement made on the system clock will see at most ± 1 microsecond of noise. Since that is the the resolution limit of time measurements, the processor clock is blind to its own flicker noise. Flicker noise is only evident when the RPi system clock is timing an external event, in which case the system clock will <a href="#timed-event">see its own noise</a> plus any noise in the event being timed. Thus any time measurements indicated below as "on the local clock" are internal and are blind to local flicker noise.</p>
<p>It has been determined that the system clock oscillator synchronized by pps-client has a maximum drift on the order of less than 100 nanoseconds per second (on the local clock). That can be verified on any RPi that has been running for at least a day by saving a file of frequency data and examining Allan deviation: </p><pre class="fragment">$ pps-client -s frequency-vars
$ cat /var/local/pps-frequency-vars
</pre><p>Consequently, any interval measurement of one second or less on the system clock will have an average error smaller than 1 microsecond (on the local clock). That will, in fact, be true of any time measurement because whole seconds are synchronized to the PPS signal. This verifies that the RPi system clock has a precision of 1 microsecond with respect to the independent <code>sysDelay</code> value determined by the <a href="#feedforward-compensator">feedforward compensation</a> mechanism, but does not verify that the <code>sysDelay</code> value is correct.</p>
<p>To verify absolute time accuracy, a pair of repetitive pulses is necessary with the first pulse replacing the PPS time source and the second pulse providing a time value to be measured by the RPi system clock. If the time reported by the RPi system clock agrees with the known time interval between the pulses to within an acceptable error then absolute time accuracy is verified.</p>
<p>Ideally, the pulses would be generated by laboratory equipment. But precision test gear is not generally available and, fortunately, is not really necessary. Since RPi processors will have flicker noise that is about the same from unit to unit then one RPi can be configured as a timing pulse generator to test a second RPi. The result of the timing will have the combined flicker noise of both RPi units. Since the noise distributions of these independent noise sources add in <a href="https://en.wikipedia.org/wiki/Root_mean_square">RMS</a> fashion, then if the flicker noise in the units is about equal then the combined distribution will be wider than that of a single unit by about √2. Since all tests will be the result of evaluating the peaks of noise distributions over a large number of trials, the widening of the distribution will have a negligible effect.</p>
<h3><a class="anchor" id="the-pulse-generator-utility"></a>
The pulse-generator Utility</h3>
<p>The pulse generator used for testing is a small program that is installed along with pps-client. It can generate repeating single pulses or pulse pairs each second at times specified in microseconds and with a precision of 1 microsecond (on the local clock). Pulses have a duration of 10 microseconds. To use the utility, load the driver, specifying the GPIO outputs or single output that will provide the pulses.</p>
<p>Because pulse-generator runs as a real-time process, pulses should not be generated at zero in order to avoid conflict with pps-client. </p><pre class="fragment">$ sudo pulse-generator load-driver &lt;GPIO_num1&gt; [GPIO_num2]
</pre><p>Then run the utility, specifying the times of the output pulses with, </p><pre class="fragment">$ sudo pulse-generator &lt;time1&gt; [time2]
</pre><p>You can stop it with ctrl-c. However, when pulse-generator is started over a terminal and the terminal disconnects for any reason, that will also stop it. To prevent it from stopping during a long test it can be started as a detached process: </p><pre class="fragment">$ sudo pulse-generator &lt;time1&gt; [time2] &amp;
</pre><p>In this case it can be stopped with </p><pre class="fragment">$ sudo kill `pidof pulse-generator`
</pre><p>Notice that back quotes are used instead of single quotes.</p>
<p>When finished, unload the driver with </p><pre class="fragment">$ sudo pulse-generator unload-driver
</pre><p>Pulses are generated by a kernel driver in a spin loop that constantly checks the system time with a kernel function <code>do_gettimeofday()</code> that returns the time within about half a microsecond so that, as soon as the specified times occur, the GPIO output(s) are asserted. This technique inherently has high linearity because time on the local clock is linear to within the error introduced by flicker noise in the clock oscillator.</p>
<p>The pulse-generator does not use interrupts - a fact that appears to minimize sporadic system latency. After each pulse is generated, pulse-generator prints the time of occurrence to the console. If a pulse is delayed more than 1 microsecond by latency it is omitted and a message to that effect is printed followed by the time the omitted pulse would have occurred. This typically occurs only a few times in 24 hours.</p>
<h3><a class="anchor" id="the-interrupt-timer-utility"></a>
The interrupt-timer Utility</h3>
<p>To time interrupts generated by external pulses, a second utility, "interrupt-timer" is provided that is also installed on the RPi along with pps-client. The interrupt-timer utility is insensitive to omitted interrupt pulses. When it receives a pulse, it prints the reception time of the interrupt to the terminal and also records a distribution of the fractional seconds part of the time to a file <code>/var/local/timer-distrib-forming</code> that is copied to <code>/var/local/timer-distrib</code> every 24 hours. This timing-collection mode is used to validate the accuracy of pps-client. For the details see the <a href="#testing-accuracy">Testing Accuracy</a> section below.</p>
<p>The interrupt-timer can be run from the command line of any terminal communicating with the RPi. To use it, load the driver specifying the GPIO number of the pin that will provide the interrupt: </p><pre class="fragment">$ sudo interrupt-timer load-driver &lt;GPIO number&gt;
</pre><p>Then run the <code>interrupt-timer</code> with, </p><pre class="fragment">$ sudo interrupt-timer
</pre><p>You can stop it with ctrl-c. However, when interrupt-timer is started over a terminal and the terminal disconnects for any reason, that will also stop it. To prevent it from stopping during a long test it can be started as a detached process: </p><pre class="fragment">$ sudo interrupt-timer &amp;
</pre><p>In this case it can be stopped with </p><pre class="fragment">$ sudo kill `pidof interrupt-timer`
</pre><p>Notice that back quotes are used instead of single quotes.</p>
<p>When finished, unload the driver with, </p><pre class="fragment">$ sudo interrupt-timer unload-driver
</pre><p>Because any interrupt time reported by the system is always later by the delay introduced by system latency, interrupt-timer compensates for system interrupt delay by reading the <code>sysDelay</code> value recorded by pps-client and subtracting it from the measured time of the interrupt internally recorded by interrupt-timer. This generates a reported time of the external interrupt <em>t<sub> r</sub></em> that adjusts the measured time of the interrupt <em>t<sub> m</sub></em> by the value of <code>sysDelay</code>, <em>d<sub> sys</sub></em>,</p>
<center><em>t<sub> r</sub></em> = <em>t<sub> m</sub></em> - <em>d<sub> sys</sub></em></center><p>in exactly the same way that the reported time of the zero crossing of the second, <em>t<sub> r0</sub></em>, is the measured time of the PPS interrupt, <em>t<sub> m0</sub></em>, adjusted for <code>sysDelay</code>:</p>
<center><em>t<sub> r0</sub></em> = <em>t<sub> m0</sub></em> - <em>d<sub> sys</sub></em></center><p>But since the <a href="#feedforward-compensator">feedforward compensator</a> determines the value of <em>d<sub> sys</sub></em> and the feedback controller forces <em>t<sub> r0</sub></em> to be zero then the only question is did the feedforward compensator determine the correct value for <em>d<sub> sys</sub></em> If it did then the reported value of the time of the interrupt <em>t<sub> r</sub></em> in the first equation should be the true time of the interrupt relative to the PPS. That is exactly what accuracy testing establishes.</p>
<h3><a class="anchor" id="normaldistribparams-utility"></a>
The NormalDistribParams Utility</h3>
<p>The distributions obtained in testing pps-client are usually narrow which makes it difficult to estimate offset errors and standard deviations. Moreover there is ample evidence that the random component of the pps-client distriutions is well-modeled by a normal distribution but is also effectively binned by the 1 microsecond resolution of the system clock. The <code>NormalDistribParams</code> program makes it possible to directly compute normal distribution parameters from binned values of a sample distribution.</p>
<p>The program fits an ideal normal distribution to the three binned sample values that wrap around the peak of the distribution. While it is always possible to fit a normal distribution to any pair of sample points, only particular normal distributions will fit three sample points. Moreover only a specific combination of three sample points will fit a normal distribution with a specific sample size. If the sample distribution is not normal, there will be a conformance error which is largest in the fit of the mean. The conformance error in the mean is a measure of the reliability of the calculated values of both ideal mean and ideal SD as they apply to the sample distribution.</p>
<p>The program can be used to determine mean and SD for any of the sample distributions collected in testing pps-client. For example, the jitter distribution in <a href="#raspberry-pi-3">Figure 2a</a> was evaluated for mean and standard deviation by providing the sample numbers for the sample bins near zero like this, </p><pre class="fragment">RPi-1:~ $ NormalDistribParams 5432 -2 17947 -1 38811 0
Relative to an ideal normal distribution:
mean:  0.133324 error: 0.031811
stddev: 0.988039 error: 0.156158
Simulation error: 0.000015
</pre><p>In this example, the positive side of the distribution is not quite normally distributed because of the system interrupt latency evident in the log plot. So the left side three points were chosen which resulted in a reasonably good fit.</p>
<p>Also in this example, sample numbers were internally normalized to a default total sample size of 86,400. But an arbitrary sample size can be provided as an additional entry following the sample counts and bin locations. To keep data entry as simple as possible, sample bin locations must be relative to zero and the peak of the distribution should be near zero. For a peak value near some other number just treat that number as zero and adjacent bin locations as relative to zero.</p>
<p>Experience indicates that for a reliable fit, simulation error must be less than 0.0001 and mean error should be less than about 0.05.</p>
<h3><a class="anchor" id="testing-accuracy"></a>
Testing Accuracy</h3>
<p>To minimize the effects of flicker noise and latency, accuracy testing consists of making a large number of independent time interval measurements and then statistically evaluating the results. This circumvents flicker noise in the oscillators of both the RPi unit under test and the RPi unit used to provide timing pulses.</p>
<p>The pulse-generator utility runs in two-pulse mode on an RPi identified as RPi-1 that is connected to a GPS receiver providing the PPS signal. The pulse-generator on RPi-1 provides both Pulse 1 as the PPS signal to RPi-2 and Pulse 2 as the pulse to be timed. The interrupt-timer utility is used on the RPi-2 to time the reception of Pulse 2.</p>
<p>Timing pulses are received each second by interrupt-timer on RPi-2. Validation is successful if the average time of reception of Pulse 2 is equal to the time difference between the times of Pulse 2 and Pulse 1 (generated on RPi-1) with sufficiently small error.</p>
<p>In order to get low-latency timings it was necessary for interrupt-timer to sleep until just before the expected time of arrival of Pulse 2. So that technique is built into interrupt-timer. Timings that did not use this technique contained substantially more sporadic system interrupt latency.</p>
<h4><a class="anchor" id="test-setup"></a>
Test Setup</h4>
<div class="image">
<img src="accuracy_verify.jpg" alt="accuracy_verify.jpg"/>
<div class="caption">
Accuracy Testing</div></div>
<p> In these tests, GPIO_23 and GPIO_25 are used for Pulse 1 and Pulse 2, respectively. Pulse 1 provides the PPS signal to RPi-2 and Pulse 2 goes to the GPIO input that is timed by interrupt-timer. The RPi units are wired as follows: </p><pre class="fragment">RPi-1 0V      ---&gt; RPi-2 0V      (Signal Ground)
RPi-1 GPIO_23 ---&gt; RPi-2 GPIO_4  (PPS input)
RPi-1 GPIO_25 ---&gt; RPi-2 GPIO_24 (interrupt-timer input)
</pre><p>This connection is also made on both RPi-1 and RPi-2 to support self calibration: </p><pre class="fragment">RPi-2 GPIO_17 ---&gt; GPIO_22
</pre><p>The diagram below shows those connections (the self-calibration connection for RPi-1 is already made on the GPS board by the yellow jumper in the photo).</p>
<div class="image">
<img src="wiring.png" alt="wiring.png"/>
<div class="caption">
Accuracy Test Wiring</div></div>
<p> After running pps-client on RPi-1 to at least a sequence count of 1200 to allow it to stabilize, the pulse-generator is started on RPi-1 with pulses at 100 μsec and 900 μsec with, </p><pre class="fragment">RPi-1:~ $ sudo pulse-generator load-driver 23 25
RPi-1:~ $ sudo pulse-generator -p 100000 900000 &amp;
</pre><p>Once the pulse generator is providing the PPS input, pps-client is started on RPi-2 and is allowed to stabilize to a minimum sequence count of 1200. At that point the interrupt-timer utility is loaded on RPi-2 with </p><pre class="fragment">RPi-2:~ $ sudo interrupt-timer load-driver 24
</pre><p>Then interrupt-timer is started in timing collection mode and is allowed to collect interrupt times for 24 hours from GPIO 24 on RPi-2 with </p><pre class="fragment">RPi-2:~ $ sudo interrupt-timer &amp;
</pre><p>The test is completed when the the <code>timer-distrib</code> file, containing the distribtion of recorded interrupt times, becomes available in the <code>/var/local</code> directory.</p>
<h4><a class="anchor" id="test-results"></a>
Test Results</h4>
<p>This test as described above was performed on ten Raspberry Pi 3 processors under low system load. Timings were collected over a period of 24 hours with typical results like that shown in Figure 6.</p>
<div class="image">
<img src="InterruptTimerDistrib.png" alt="InterruptTimerDistrib.png"/>
<div class="caption">
System Clock Accuracy</div></div>
<p> The distribution shows the average recorded pulse time for this distribution (RPi3#2) to be about 0.16 microsecond lower than the ideal time of 800,000 microseconds. The log plot shows that for this unit, pulses were received with a delay as much as 20 μsecs because of sporadic Linux system interrupt latency.</p>
<p>The results collected for all ten units are shown in the table below. The indicated tolerances are the conformance errors to an ideal normal distribution provided by the <code>NormalDistribParams</code> utility. </p><pre class="fragment">--- System Clock Error (microseconds) ---
UNIT#      offset             stddev
-----------------------------------------
RPi3#1  -0.76  +/-0.01    1.00  +/-0.01
RPi3#2  -0.16  +/-0.01    1.005 +/-0.002
RPi3#3  -0.29  +/-0.01    1.029 +/-0.003
RPi3#4  -0.398 +/-0.002   0.969 +/-0.001
RPi3#5  -0.598 +/-0.003   1.049 +/-0.003
RPi3#6  -0.419 +/-0.0     1.088 +/-0.0
RPi3#7  -0.16  +/-0.02    1.043 +/-0.003
RPi3#8   0.21  +/-0.06    1.00  +/-0.01
RPi3#9  -0.22  +/-0.01    1.081 +/-0.003
RPi3#10 -0.21  +/-0.01    0.916 +/-0.003</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Nov 23 2016 11:14:07 for PPS-Client by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
